[
    {
        "path": "DefaultPluginManager.java",
        "summary": "Access to the artifact list of a plugin",
        "parent": false,
        "code": "    protected void addPlugin( String pluginKey, Artifact pluginArtifact, MavenProject project,\n                             ArtifactRepository localRepository )\n        throws ArtifactResolutionException, ComponentLookupException, PlexusContainerException\n    {\n        ArtifactResolver artifactResolver = null;\n        MavenProjectBuilder mavenProjectBuilder = null;\n\n        try\n        {\n            artifactResolver = (ArtifactResolver) container.lookup( ArtifactResolver.ROLE );\n\n            mavenProjectBuilder = (MavenProjectBuilder) container.lookup( MavenProjectBuilder.ROLE );\n\n            MavenMetadataSource metadataSource = new MavenMetadataSource( artifactResolver, mavenProjectBuilder );\n\n            ArtifactResolutionResult result = artifactResolver.resolveTransitively( Collections\n                .singleton( pluginArtifact ), project.getRemoteArtifactRepositories(), localRepository, metadataSource,\n                                                                                    artifactFilter );\n\n            Map resolved = result.getArtifacts();\n\n            List files = new ArrayList();\n\n            for ( Iterator it = resolved.values().iterator(); it.hasNext(); )\n            {\n                Artifact artifact = (Artifact) it.next();\n\n                files.add( artifact.getFile() );\n            }\n\n            container.createChildContainer( pluginKey, files, Collections.EMPTY_MAP, Collections.singletonList( this ) );\n            \n            // this plugin's descriptor should have been discovered by now, so we should be able to circle\n            // around and set the artifacts.\n            PluginDescriptor addedPlugin = (PluginDescriptor) pluginDescriptors.get( pluginKey );\n\n            addedPlugin.setArtifacts( new ArrayList( resolved.values() ) );\n        }\n        finally\n        {\n            if ( artifactResolver != null )\n            {\n                releaseComponent( artifactResolver );\n            }\n            if ( mavenProjectBuilder != null )\n            {\n                releaseComponent( mavenProjectBuilder );\n            }\n        }\n    }",
        "start_line": 270,
        "changed": true,
        "commit": "1",
        "end_line": 319,
        "issue": "MNG-455",
        "description": "<p>When making plugins that will fork a java process and when this process requires all the dependencies of the plugin to be on the classpath this would be needed.</p>",
        "nl_input": "Access to the artifact list of a plugin\nWhen making plugins that will fork a java process and when this process requires all the dependencies of the plugin to be on the classpath this would be needed.",
        "method_name": "addPlugin"
    },
    {
        "path": "DefaultPluginManager.java",
        "summary": "Access to the artifact list of a plugin",
        "parent": false,
        "code": "    public void executeMojo( MavenSession session, GoalInstance goalInstance )\n        throws ArtifactResolutionException, PluginManagerException, MojoExecutionException\n    {\n        PlexusContainer pluginContainer = null;\n\n        MojoDescriptor mojoDescriptor = goalInstance.getMojoDescriptor();\n\n        if ( mojoDescriptor.isDependencyResolutionRequired() != null )\n        {\n\n            ArtifactResolver artifactResolver = null;\n            MavenProjectBuilder mavenProjectBuilder = null;\n\n            try\n            {\n                artifactResolver = (ArtifactResolver) container.lookup( ArtifactResolver.ROLE );\n                mavenProjectBuilder = (MavenProjectBuilder) container.lookup( MavenProjectBuilder.ROLE );\n\n                resolveTransitiveDependencies( session, artifactResolver, mavenProjectBuilder, mojoDescriptor\n                    .isDependencyResolutionRequired() );\n                downloadDependencies( session, artifactResolver );\n            }\n            catch ( ComponentLookupException e )\n            {\n                throw new PluginManagerException( \"Internal configuration error in plugin manager\", e );\n            }\n            finally\n            {\n                if ( artifactResolver != null )\n                {\n                    releaseComponent( artifactResolver );\n                }\n                if ( mavenProjectBuilder != null )\n                {\n                    releaseComponent( mavenProjectBuilder );\n                }\n            }\n        }\n\n        Mojo plugin = null;\n\n        String goalName = mojoDescriptor.getFullGoalName();\n\n        try\n        {\n            String pluginKey = mojoDescriptor.getPluginDescriptor().getPluginLookupKey();\n\n            pluginContainer = container.getChildContainer( pluginKey );\n\n            if ( pluginContainer == null )\n            {\n                throw new PluginConfigurationException( \"Cannot find PlexusContainer for plugin: \" + pluginKey );\n            }\n\n            plugin = (Mojo) pluginContainer.lookup( Mojo.ROLE, mojoDescriptor.getRoleHint() );\n            plugin.setLog( mojoLogger );\n\n            String goalId = goalInstance.getGoalId();\n\n            PluginDescriptor pluginDescriptor = mojoDescriptor.getPluginDescriptor();\n\n            Xpp3Dom dom = goalInstance.getCalculatedConfiguration();\n\n            PlexusConfiguration pomConfiguration;\n            if ( dom == null )\n            {\n                pomConfiguration = new XmlPlexusConfiguration( \"configuration\" );\n            }\n            else\n            {\n                pomConfiguration = new XmlPlexusConfiguration( dom );\n            }\n\n            // Validate against non-editable (@readonly) parameters, to make sure users aren't trying to\n            // override in the POM.\n            validatePomConfiguration( mojoDescriptor, pomConfiguration );\n\n            PlexusConfiguration mergedConfiguration = mergeConfiguration( pomConfiguration, mojoDescriptor\n                .getMojoConfiguration() );\n\n            // TODO: plexus\n            //            PlexusConfiguration mergedConfiguration = mergeConfiguration( pomConfiguration,\n            //                                                                          mojoDescriptor.getConfiguration() );\n\n            ExpressionEvaluator expressionEvaluator = new PluginParameterExpressionEvaluator( session,\n                                                                                              pluginDescriptor,\n                                                                                              pathTranslator,\n                                                                                              getLogger() );\n            \n            checkRequiredParameters( mojoDescriptor, mergedConfiguration, expressionEvaluator, plugin );\n\n            populatePluginFields( plugin, mojoDescriptor, mergedConfiguration, pluginContainer, expressionEvaluator );\n\n            // !! This is ripe for refactoring to an aspect.\n            // Event monitoring.\n            String event = MavenEvents.MOJO_EXECUTION;\n            EventDispatcher dispatcher = session.getEventDispatcher();\n            \n            String goalExecId = goalName;\n            \n            if ( goalInstance.getExecutionId() != null )\n            {\n                goalExecId += \" {execution: \" + goalInstance.getExecutionId() + \"}\";\n            }\n\n            dispatcher.dispatchStart( event, goalExecId );\n            try\n            {\n                plugin.execute();\n\n                dispatcher.dispatchEnd( event, goalExecId );\n            }\n            catch ( MojoExecutionException e )\n            {\n                session.getEventDispatcher().dispatchError( event, goalExecId, e );\n                \n                throw e;\n            }\n            // End event monitoring.\n\n        }\n        catch ( PluginConfigurationException e )\n        {\n            String msg = \"Error configuring plugin for execution of '\" + goalName + \"'.\";\n            throw new MojoExecutionException( msg, e );\n        }\n        catch ( ComponentLookupException e )\n        {\n            throw new MojoExecutionException( \"Error looking up plugin: \", e );\n        }\n        finally\n        {\n            try\n            {\n                pluginContainer.release( plugin );\n            }\n            catch ( ComponentLifecycleException e )\n            {\n                if ( getLogger().isErrorEnabled() )\n                {\n                    getLogger().error( \"Error releasing plugin - ignoring.\", e );\n                }\n            }\n        }\n    }",
        "start_line": 337,
        "changed": true,
        "commit": "1",
        "end_line": 481,
        "issue": "MNG-455",
        "description": "<p>When making plugins that will fork a java process and when this process requires all the dependencies of the plugin to be on the classpath this would be needed.</p>",
        "nl_input": "Access to the artifact list of a plugin\nWhen making plugins that will fork a java process and when this process requires all the dependencies of the plugin to be on the classpath this would be needed.",
        "method_name": "executeMojo"
    },
    {
        "path": "DefaultPluginManager.java",
        "summary": "Access to the artifact list of a plugin",
        "parent": false,
        "code": "    public void componentDiscovered( ComponentDiscoveryEvent event )\n    {\n        ComponentSetDescriptor componentSetDescriptor = event.getComponentSetDescriptor();\n\n        if ( componentSetDescriptor instanceof PluginDescriptor )\n        {\n            PluginDescriptor pluginDescriptor = (PluginDescriptor) componentSetDescriptor;\n\n            //            String key = pluginDescriptor.getId();\n            // TODO: see comment in getPluginDescriptor\n            String key = pluginDescriptor.getGroupId() + \":\" + pluginDescriptor.getArtifactId();\n\n            if ( !pluginsInProcess.contains( key ) )\n            {\n                pluginsInProcess.add( key );\n\n                pluginDescriptors.put( key, pluginDescriptor );\n\n                // TODO: throw an (not runtime) exception if there is a prefix overlap - means doing so elsewhere\n                if ( !pluginDescriptorsByPrefix.containsKey( pluginDescriptor.getGoalPrefix() ) )\n                {\n                    pluginDescriptorsByPrefix.put( pluginDescriptor.getGoalPrefix(), pluginDescriptor );\n                }\n            }\n        }\n    }",
        "start_line": 111,
        "changed": true,
        "commit": "3",
        "end_line": 136,
        "issue": "MNG-455",
        "description": "<p>When making plugins that will fork a java process and when this process requires all the dependencies of the plugin to be on the classpath this would be needed.</p>",
        "nl_input": "Access to the artifact list of a plugin\nWhen making plugins that will fork a java process and when this process requires all the dependencies of the plugin to be on the classpath this would be needed.",
        "method_name": "componentDiscovered"
    },
    {
        "path": "DefaultPluginManager.java",
        "summary": "Access to the artifact list of a plugin",
        "parent": false,
        "code": "    private PluginDescriptor getPluginDescriptor( String groupId, String artifactId, String version )\n    {\n        //        String key = PluginDescriptor.constructPluginKey( groupId, artifactId, version );\n        // TODO: include version, but can't do this in the plugin manager as it is not resolved to the right version\n        // at that point. Instead, move the duplication check to the artifact container, or store it locally based on\n        // the unresolved version?\n        String key = groupId + \":\" + artifactId;\n        return (PluginDescriptor) pluginDescriptors.get( key );\n    }",
        "start_line": 142,
        "changed": true,
        "commit": "3",
        "end_line": 150,
        "issue": "MNG-455",
        "description": "<p>When making plugins that will fork a java process and when this process requires all the dependencies of the plugin to be on the classpath this would be needed.</p>",
        "nl_input": "Access to the artifact list of a plugin\nWhen making plugins that will fork a java process and when this process requires all the dependencies of the plugin to be on the classpath this would be needed.",
        "method_name": "getPluginDescriptor"
    },
    {
        "path": "DefaultPluginManager.java",
        "summary": "Access to the artifact list of a plugin",
        "parent": false,
        "code": "    private PluginDescriptor getPluginDescriptor( String prefix )\n    {\n        return (PluginDescriptor) pluginDescriptorsByPrefix.get( prefix );\n    }",
        "start_line": 152,
        "changed": true,
        "commit": "3",
        "end_line": 155,
        "issue": "MNG-455",
        "description": "<p>When making plugins that will fork a java process and when this process requires all the dependencies of the plugin to be on the classpath this would be needed.</p>",
        "nl_input": "Access to the artifact list of a plugin\nWhen making plugins that will fork a java process and when this process requires all the dependencies of the plugin to be on the classpath this would be needed.",
        "method_name": "getPluginDescriptor"
    },
    {
        "path": "DefaultPluginManager.java",
        "summary": "Access to the artifact list of a plugin",
        "parent": false,
        "code": "    private boolean isPluginInstalled( String pluginKey )\n    {\n        //        String key = PluginDescriptor.constructPluginKey( groupId, artifactId, version );\n        // TODO: see comment in getPluginDescriptor\n        return pluginDescriptors.containsKey( pluginKey );\n    }",
        "start_line": 157,
        "changed": true,
        "commit": "3",
        "end_line": 162,
        "issue": "MNG-455",
        "description": "<p>When making plugins that will fork a java process and when this process requires all the dependencies of the plugin to be on the classpath this would be needed.</p>",
        "nl_input": "Access to the artifact list of a plugin\nWhen making plugins that will fork a java process and when this process requires all the dependencies of the plugin to be on the classpath this would be needed.",
        "method_name": "isPluginInstalled"
    },
    {
        "path": "DefaultPluginManager.java",
        "summary": "Access to the artifact list of a plugin",
        "parent": false,
        "code": "    private boolean isPluginInstalledForPrefix( String prefix )\n    {\n        return pluginDescriptorsByPrefix.containsKey( prefix );\n    }",
        "start_line": 164,
        "changed": true,
        "commit": "3",
        "end_line": 167,
        "issue": "MNG-455",
        "description": "<p>When making plugins that will fork a java process and when this process requires all the dependencies of the plugin to be on the classpath this would be needed.</p>",
        "nl_input": "Access to the artifact list of a plugin\nWhen making plugins that will fork a java process and when this process requires all the dependencies of the plugin to be on the classpath this would be needed.",
        "method_name": "isPluginInstalledForPrefix"
    },
    {
        "path": "DefaultPluginManager.java",
        "summary": "Access to the artifact list of a plugin",
        "parent": false,
        "code": "    public PluginDescriptor verifyPlugin( String prefix )\n    {\n        if ( !isPluginInstalledForPrefix( prefix ) )\n        {\n            // TODO: lookup remotely\n        }\n        return getPluginDescriptor( prefix );\n    }",
        "start_line": 169,
        "changed": true,
        "commit": "3",
        "end_line": 176,
        "issue": "MNG-455",
        "description": "<p>When making plugins that will fork a java process and when this process requires all the dependencies of the plugin to be on the classpath this would be needed.</p>",
        "nl_input": "Access to the artifact list of a plugin\nWhen making plugins that will fork a java process and when this process requires all the dependencies of the plugin to be on the classpath this would be needed.",
        "method_name": "verifyPlugin"
    },
    {
        "path": "DefaultPluginManager.java",
        "summary": "Access to the artifact list of a plugin",
        "parent": false,
        "code": "    public PluginDescriptor verifyPlugin( String groupId, String artifactId, String version, MavenProject project,\n                                         ArtifactRepository localRepository )\n        throws ArtifactResolutionException, PluginManagerException\n    {\n\n        String pluginKey = groupId + \":\" + artifactId;\n\n        // TODO: this should be possibly outside\n        if ( version == null )\n        {\n\n            Plugin pluginConfig = null;\n\n            for ( Iterator it = project.getBuildPlugins().iterator(); it.hasNext(); )\n            {\n                Plugin plugin = (Plugin) it.next();\n\n                if ( groupId.equals( plugin.getGroupId() ) && artifactId.equals( plugin.getArtifactId() ) )\n                {\n                    pluginConfig = plugin;\n\n                    break;\n                }\n            }\n\n            if ( project.getReports() != null )\n            {\n                for ( Iterator it = project.getReports().getPlugins().iterator(); it.hasNext(); )\n                {\n                    Plugin plugin = (Plugin) it.next();\n\n                    if ( groupId.equals( plugin.getGroupId() ) && artifactId.equals( plugin.getArtifactId() ) )\n                    {\n                        pluginConfig = plugin;\n\n                        break;\n                    }\n                }\n            }\n\n            if ( pluginConfig != null )\n            {\n                if ( StringUtils.isEmpty( pluginConfig.getVersion() ) )\n                {\n                    version = ReleaseArtifactTransformation.RELEASE_VERSION;\n                }\n                else\n                {\n                    version = pluginConfig.getVersion();\n                }\n            }\n        }\n\n        // TODO: this might result in an artifact \"RELEASE\" being resolved continuously\n        if ( !isPluginInstalled( pluginKey ) )\n        {\n            try\n            {\n                Artifact pluginArtifact = artifactFactory.createArtifact( groupId, artifactId, version,\n                                                                          Artifact.SCOPE_RUNTIME,\n                                                                          MojoDescriptor.MAVEN_PLUGIN, null );\n\n                addPlugin( pluginKey, pluginArtifact, project, localRepository );\n\n                version = pluginArtifact.getBaseVersion();\n            }\n            catch ( PlexusContainerException e )\n            {\n                throw new PluginManagerException(\n                                                  \"Error occurred in the artifact container attempting to download plugin \"\n                                                      + groupId + \":\" + artifactId, e );\n            }\n            catch ( ArtifactResolutionException e )\n            {\n                if ( groupId.equals( e.getGroupId() ) && artifactId.equals( e.getArtifactId() )\n                    && version.equals( e.getVersion() ) && \"maven-plugin\".equals( e.getType() ) )\n                {\n                    throw new PluginNotFoundException( e );\n                }\n                else\n                {\n                    throw e;\n                }\n            }\n            catch ( ComponentLookupException e )\n            {\n                throw new PluginManagerException( \"Internal configuration error while retrieving \" + groupId + \":\"\n                    + artifactId, e );\n            }\n        }\n        return getPluginDescriptor( groupId, artifactId, version );\n    }",
        "start_line": 178,
        "changed": true,
        "commit": "3",
        "end_line": 269,
        "issue": "MNG-455",
        "description": "<p>When making plugins that will fork a java process and when this process requires all the dependencies of the plugin to be on the classpath this would be needed.</p>",
        "nl_input": "Access to the artifact list of a plugin\nWhen making plugins that will fork a java process and when this process requires all the dependencies of the plugin to be on the classpath this would be needed.",
        "method_name": "verifyPlugin"
    },
    {
        "path": "DefaultPluginManager.java",
        "summary": "Access to the artifact list of a plugin",
        "parent": false,
        "code": "    protected void addPlugin( String pluginKey, Artifact pluginArtifact, MavenProject project,\n                             ArtifactRepository localRepository )\n        throws ArtifactResolutionException, ComponentLookupException, PlexusContainerException\n    {\n        ArtifactResolver artifactResolver = null;\n        MavenProjectBuilder mavenProjectBuilder = null;\n\n        try\n        {\n            artifactResolver = (ArtifactResolver) container.lookup( ArtifactResolver.ROLE );\n\n            mavenProjectBuilder = (MavenProjectBuilder) container.lookup( MavenProjectBuilder.ROLE );\n\n            MavenMetadataSource metadataSource = new MavenMetadataSource( artifactResolver, mavenProjectBuilder );\n\n            ArtifactResolutionResult result = artifactResolver.resolveTransitively( Collections\n                .singleton( pluginArtifact ), project.getRemoteArtifactRepositories(), localRepository, metadataSource,\n                                                                                    artifactFilter );\n\n            Map resolved = result.getArtifacts();\n\n            List files = new ArrayList();\n\n            for ( Iterator it = resolved.values().iterator(); it.hasNext(); )\n            {\n                Artifact artifact = (Artifact) it.next();\n\n                files.add( artifact.getFile() );\n            }\n\n            container.createChildContainer( pluginKey, files, Collections.EMPTY_MAP, Collections.singletonList( this ) );\n        }\n        finally\n        {\n            if ( artifactResolver != null )\n            {\n                releaseComponent( artifactResolver );\n            }\n            if ( mavenProjectBuilder != null )\n            {\n                releaseComponent( mavenProjectBuilder );\n            }\n        }\n    }",
        "start_line": 271,
        "changed": true,
        "commit": "3",
        "end_line": 314,
        "issue": "MNG-455",
        "description": "<p>When making plugins that will fork a java process and when this process requires all the dependencies of the plugin to be on the classpath this would be needed.</p>",
        "nl_input": "Access to the artifact list of a plugin\nWhen making plugins that will fork a java process and when this process requires all the dependencies of the plugin to be on the classpath this would be needed.",
        "method_name": "addPlugin"
    },
    {
        "path": "DefaultPluginManager.java",
        "summary": "Access to the artifact list of a plugin",
        "parent": false,
        "code": "    private void releaseComponent( Object component )\n    {\n        try\n        {\n            container.release( component );\n        }\n        catch ( ComponentLifecycleException e )\n        {\n            getLogger().error( \"Error releasing component - ignoring\", e );\n        }\n    }",
        "start_line": 316,
        "changed": true,
        "commit": "3",
        "end_line": 326,
        "issue": "MNG-455",
        "description": "<p>When making plugins that will fork a java process and when this process requires all the dependencies of the plugin to be on the classpath this would be needed.</p>",
        "nl_input": "Access to the artifact list of a plugin\nWhen making plugins that will fork a java process and when this process requires all the dependencies of the plugin to be on the classpath this would be needed.",
        "method_name": "releaseComponent"
    },
    {
        "path": "DefaultPluginManager.java",
        "summary": "Access to the artifact list of a plugin",
        "parent": false,
        "code": "    public void executeMojo( MavenSession session, GoalInstance goalInstance )\n        throws ArtifactResolutionException, PluginManagerException, MojoExecutionException\n    {\n        PlexusContainer pluginContainer = null;\n\n        MojoDescriptor mojoDescriptor = goalInstance.getMojoDescriptor();\n\n        if ( mojoDescriptor.isDependencyResolutionRequired() != null )\n        {\n\n            ArtifactResolver artifactResolver = null;\n            MavenProjectBuilder mavenProjectBuilder = null;\n\n            try\n            {\n                artifactResolver = (ArtifactResolver) container.lookup( ArtifactResolver.ROLE );\n                mavenProjectBuilder = (MavenProjectBuilder) container.lookup( MavenProjectBuilder.ROLE );\n\n                resolveTransitiveDependencies( session, artifactResolver, mavenProjectBuilder, mojoDescriptor\n                    .isDependencyResolutionRequired() );\n                downloadDependencies( session, artifactResolver );\n            }\n            catch ( ComponentLookupException e )\n            {\n                throw new PluginManagerException( \"Internal configuration error in plugin manager\", e );\n            }\n            finally\n            {\n                if ( artifactResolver != null )\n                {\n                    releaseComponent( artifactResolver );\n                }\n                if ( mavenProjectBuilder != null )\n                {\n                    releaseComponent( mavenProjectBuilder );\n                }\n            }\n        }\n\n        Mojo plugin = null;\n\n        String goalName = mojoDescriptor.getFullGoalName();\n\n        try\n        {\n            String pluginKey = mojoDescriptor.getPluginDescriptor().getPluginLookupKey();\n\n            pluginContainer = container.getChildContainer( pluginKey );\n\n            if ( pluginContainer == null )\n            {\n                throw new PluginConfigurationException( \"Cannot find PlexusContainer for plugin: \" + pluginKey );\n            }\n\n            plugin = (Mojo) pluginContainer.lookup( Mojo.ROLE, mojoDescriptor.getRoleHint() );\n            plugin.setLog( mojoLogger );\n\n            String goalId = goalInstance.getGoalId();\n\n            PluginDescriptor pluginDescriptor = mojoDescriptor.getPluginDescriptor();\n\n            Xpp3Dom dom = goalInstance.getCalculatedConfiguration();\n\n            PlexusConfiguration pomConfiguration;\n            if ( dom == null )\n            {\n                pomConfiguration = new XmlPlexusConfiguration( \"configuration\" );\n            }\n            else\n            {\n                pomConfiguration = new XmlPlexusConfiguration( dom );\n            }\n\n            // Validate against non-editable (@readonly) parameters, to make sure users aren't trying to\n            // override in the POM.\n            validatePomConfiguration( mojoDescriptor, pomConfiguration );\n\n            PlexusConfiguration mergedConfiguration = mergeConfiguration( pomConfiguration, mojoDescriptor\n                .getMojoConfiguration() );\n\n            // TODO: plexus\n            //            PlexusConfiguration mergedConfiguration = mergeConfiguration( pomConfiguration,\n            //                                                                          mojoDescriptor.getConfiguration() );\n\n            ExpressionEvaluator expressionEvaluator = new PluginParameterExpressionEvaluator( session, pathTranslator,\n                                                                                              getLogger() );\n            checkRequiredParameters( mojoDescriptor, mergedConfiguration, expressionEvaluator, plugin );\n\n            populatePluginFields( plugin, mojoDescriptor, mergedConfiguration, pluginContainer, expressionEvaluator );\n\n            // !! This is ripe for refactoring to an aspect.\n            // Event monitoring.\n            String event = MavenEvents.MOJO_EXECUTION;\n            EventDispatcher dispatcher = session.getEventDispatcher();\n            \n            String goalExecId = goalName;\n            \n            if ( goalInstance.getExecutionId() != null )\n            {\n                goalExecId += \" {execution: \" + goalInstance.getExecutionId() + \"}\";\n            }\n\n            dispatcher.dispatchStart( event, goalExecId );\n            try\n            {\n                plugin.execute();\n\n                dispatcher.dispatchEnd( event, goalExecId );\n            }\n            catch ( MojoExecutionException e )\n            {\n                session.getEventDispatcher().dispatchError( event, goalExecId, e );\n                \n                throw e;\n            }\n            // End event monitoring.\n\n        }\n        catch ( PluginConfigurationException e )\n        {\n            String msg = \"Error configuring plugin for execution of '\" + goalName + \"'.\";\n            throw new MojoExecutionException( msg, e );\n        }\n        catch ( ComponentLookupException e )\n        {\n            throw new MojoExecutionException( \"Error looking up plugin: \", e );\n        }\n        finally\n        {\n            try\n            {\n                pluginContainer.release( plugin );\n            }\n            catch ( ComponentLifecycleException e )\n            {\n                if ( getLogger().isErrorEnabled() )\n                {\n                    getLogger().error( \"Error releasing plugin - ignoring.\", e );\n                }\n            }\n        }\n    }",
        "start_line": 332,
        "changed": true,
        "commit": "3",
        "end_line": 473,
        "issue": "MNG-455",
        "description": "<p>When making plugins that will fork a java process and when this process requires all the dependencies of the plugin to be on the classpath this would be needed.</p>",
        "nl_input": "Access to the artifact list of a plugin\nWhen making plugins that will fork a java process and when this process requires all the dependencies of the plugin to be on the classpath this would be needed.",
        "method_name": "executeMojo"
    },
    {
        "path": "DefaultPluginManager.java",
        "summary": "Access to the artifact list of a plugin",
        "parent": false,
        "code": "    private void checkRequiredParameters( MojoDescriptor goal, PlexusConfiguration configuration,\n                                         ExpressionEvaluator expressionEvaluator, Mojo plugin )\n        throws PluginConfigurationException\n    {\n        // TODO: this should be built in to the configurator, as we presently double process the expressions\n\n        List parameters = goal.getParameters();\n\n        List invalidParameters = new ArrayList();\n\n        for ( int i = 0; i < parameters.size(); i++ )\n        {\n            Parameter parameter = (Parameter) parameters.get( i );\n\n            if ( parameter.isRequired() )\n            {\n                // the key for the configuration map we're building.\n                String key = parameter.getName();\n\n                Object fieldValue = null;\n                String expression = null;\n                PlexusConfiguration value = configuration.getChild( key, false );\n                try\n                {\n                    if ( value != null )\n                    {\n                        expression = value.getValue( null );\n\n                        fieldValue = expressionEvaluator.evaluate( expression );\n\n                        if ( fieldValue == null )\n                        {\n                            fieldValue = value.getAttribute( \"default-value\", null );\n                        }\n                    }\n\n                    if ( fieldValue == null && StringUtils.isNotEmpty( parameter.getAlias() ) )\n                    {\n                        value = configuration.getChild( parameter.getAlias(), false );\n                        if ( value != null )\n                        {\n                            expression = value.getValue( null );\n                            fieldValue = expressionEvaluator.evaluate( expression );\n                            if ( fieldValue == null )\n                            {\n                                fieldValue = value.getAttribute( \"default-value\", null );\n                            }\n                        }\n                    }\n                }\n                catch ( ExpressionEvaluationException e )\n                {\n                    throw new PluginConfigurationException( \"Bad expression\", e );\n                }\n\n                if ( fieldValue == null && goal.getComponentConfigurator() == null )\n                {\n                    try\n                    {\n                        // TODO: remove in beta-1\n                        Field field = findPluginField( plugin.getClass(), parameter.getName() );\n                        boolean accessible = field.isAccessible();\n                        if ( !accessible )\n                        {\n                            field.setAccessible( true );\n                        }\n                        fieldValue = field.get( plugin );\n                        if ( !accessible )\n                        {\n                            field.setAccessible( false );\n                        }\n                        if ( fieldValue != null )\n                        {\n                            getLogger().warn(\n                                              \"DEPRECATED: using default-value to set the default value of field '\"\n                                                  + parameter.getName() + \"'\" );\n                        }\n                    }\n                    catch ( NoSuchFieldException e )\n                    {\n                        throw new PluginConfigurationException( \"Unable to find field to check default value\", e );\n                    }\n                    catch ( IllegalAccessException e )\n                    {\n                        throw new PluginConfigurationException( \"Unable to read field to check default value\", e );\n                    }\n                }\n\n                if ( fieldValue == null )\n                {\n                    parameter.setExpression( expression );\n                    invalidParameters.add( parameter );\n                }\n            }\n        }\n\n        if ( !invalidParameters.isEmpty() )\n        {\n            throw new PluginParameterException( goal, invalidParameters );\n        }\n    }",
        "start_line": 475,
        "changed": true,
        "commit": "3",
        "end_line": 575,
        "issue": "MNG-455",
        "description": "<p>When making plugins that will fork a java process and when this process requires all the dependencies of the plugin to be on the classpath this would be needed.</p>",
        "nl_input": "Access to the artifact list of a plugin\nWhen making plugins that will fork a java process and when this process requires all the dependencies of the plugin to be on the classpath this would be needed.",
        "method_name": "checkRequiredParameters"
    },
    {
        "path": "DefaultPluginManager.java",
        "summary": "Access to the artifact list of a plugin",
        "parent": false,
        "code": "    private void validatePomConfiguration( MojoDescriptor goal, PlexusConfiguration pomConfiguration )\n        throws PluginConfigurationException\n    {\n        List parameters = goal.getParameters();\n\n        for ( int i = 0; i < parameters.size(); i++ )\n        {\n            Parameter parameter = (Parameter) parameters.get( i );\n\n            // the key for the configuration map we're building.\n            String key = parameter.getName();\n\n            PlexusConfiguration value = pomConfiguration.getChild( key, false );\n\n            if ( value == null && StringUtils.isNotEmpty( parameter.getAlias() ) )\n            {\n                key = parameter.getAlias();\n                value = pomConfiguration.getChild( key, false );\n            }\n\n            if ( value != null )\n            {\n                // Make sure the parameter is either editable/configurable, or else is NOT specified in the POM\n                if ( !parameter.isEditable() )\n                {\n                    StringBuffer errorMessage = new StringBuffer()\n                        .append( \"ERROR: Cannot override read-only parameter: \" );\n                    errorMessage.append( key );\n                    errorMessage.append( \" in goal: \" ).append( goal.getFullGoalName() );\n\n                    throw new PluginConfigurationException( errorMessage.toString() );\n                }\n\n                String deprecated = parameter.getDeprecated();\n                if ( StringUtils.isNotEmpty( deprecated ) )\n                {\n                    getLogger().warn( \"DEPRECATED [\" + parameter.getName() + \"]: \" + deprecated );\n                }\n            }\n        }\n    }",
        "start_line": 577,
        "changed": true,
        "commit": "3",
        "end_line": 617,
        "issue": "MNG-455",
        "description": "<p>When making plugins that will fork a java process and when this process requires all the dependencies of the plugin to be on the classpath this would be needed.</p>",
        "nl_input": "Access to the artifact list of a plugin\nWhen making plugins that will fork a java process and when this process requires all the dependencies of the plugin to be on the classpath this would be needed.",
        "method_name": "validatePomConfiguration"
    },
    {
        "path": "DefaultPluginManager.java",
        "summary": "Access to the artifact list of a plugin",
        "parent": false,
        "code": "    private PlexusConfiguration mergeConfiguration( PlexusConfiguration dominant, PlexusConfiguration configuration )\n    {\n        // TODO: share with mergeXpp3Dom\n        PlexusConfiguration[] children = configuration.getChildren();\n        for ( int i = 0; i < children.length; i++ )\n        {\n            PlexusConfiguration child = children[i];\n            PlexusConfiguration childDom = (XmlPlexusConfiguration) dominant.getChild( child.getName(), false );\n            if ( childDom != null )\n            {\n                mergeConfiguration( childDom, child );\n            }\n            else\n            {\n                dominant.addChild( copyConfiguration( child ) );\n            }\n        }\n        return dominant;\n    }",
        "start_line": 619,
        "changed": true,
        "commit": "3",
        "end_line": 637,
        "issue": "MNG-455",
        "description": "<p>When making plugins that will fork a java process and when this process requires all the dependencies of the plugin to be on the classpath this would be needed.</p>",
        "nl_input": "Access to the artifact list of a plugin\nWhen making plugins that will fork a java process and when this process requires all the dependencies of the plugin to be on the classpath this would be needed.",
        "method_name": "mergeConfiguration"
    },
    {
        "path": "DefaultPluginManager.java",
        "summary": "Access to the artifact list of a plugin",
        "parent": false,
        "code": "    public static PlexusConfiguration copyConfiguration( PlexusConfiguration src )\n    {\n        // TODO: shouldn't be necessary\n        XmlPlexusConfiguration dom = new XmlPlexusConfiguration( src.getName() );\n        dom.setValue( src.getValue( null ) );\n\n        String[] attributeNames = src.getAttributeNames();\n        for ( int i = 0; i < attributeNames.length; i++ )\n        {\n            String attributeName = attributeNames[i];\n            dom.setAttribute( attributeName, src.getAttribute( attributeName, null ) );\n        }\n\n        PlexusConfiguration[] children = src.getChildren();\n        for ( int i = 0; i < children.length; i++ )\n        {\n            dom.addChild( copyConfiguration( children[i] ) );\n        }\n\n        return dom;\n    }",
        "start_line": 639,
        "changed": true,
        "commit": "3",
        "end_line": 659,
        "issue": "MNG-455",
        "description": "<p>When making plugins that will fork a java process and when this process requires all the dependencies of the plugin to be on the classpath this would be needed.</p>",
        "nl_input": "Access to the artifact list of a plugin\nWhen making plugins that will fork a java process and when this process requires all the dependencies of the plugin to be on the classpath this would be needed.",
        "method_name": "copyConfiguration"
    },
    {
        "path": "DefaultPluginManager.java",
        "summary": "Access to the artifact list of a plugin",
        "parent": false,
        "code": "    private void populatePluginFields( Mojo plugin, MojoDescriptor mojoDescriptor, PlexusConfiguration configuration,\n                                      PlexusContainer pluginContainer, ExpressionEvaluator expressionEvaluator )\n        throws PluginConfigurationException\n    {\n        ComponentConfigurator configurator = null;\n\n        try\n        {\n            String configuratorId = mojoDescriptor.getComponentConfigurator();\n\n            // TODO: should this be known to the component factory instead? And if so, should configuration be part of lookup?\n            if ( StringUtils.isNotEmpty( configuratorId ) )\n            {\n                configurator = (ComponentConfigurator) pluginContainer.lookup( ComponentConfigurator.ROLE,\n                                                                               configuratorId );\n            }\n            else\n            {\n                configurator = (ComponentConfigurator) pluginContainer.lookup( ComponentConfigurator.ROLE );\n            }\n\n            configurator.configureComponent( plugin, configuration, expressionEvaluator, pluginContainer\n                .getContainerRealm() );\n        }\n        catch ( ComponentConfigurationException e )\n        {\n            throw new PluginConfigurationException( \"Unable to parse the created DOM for plugin configuration\", e );\n        }\n        catch ( ComponentLookupException e )\n        {\n            throw new PluginConfigurationException(\n                                                    \"Unable to retrieve component configurator for plugin configuration\",\n                                                    e );\n        }\n        finally\n        {\n            if ( configurator != null )\n            {\n                try\n                {\n                    pluginContainer.release( configurator );\n                }\n                catch ( ComponentLifecycleException e )\n                {\n                }\n            }\n        }\n    }",
        "start_line": 665,
        "changed": true,
        "commit": "3",
        "end_line": 712,
        "issue": "MNG-455",
        "description": "<p>When making plugins that will fork a java process and when this process requires all the dependencies of the plugin to be on the classpath this would be needed.</p>",
        "nl_input": "Access to the artifact list of a plugin\nWhen making plugins that will fork a java process and when this process requires all the dependencies of the plugin to be on the classpath this would be needed.",
        "method_name": "populatePluginFields"
    },
    {
        "path": "DefaultPluginManager.java",
        "summary": "Access to the artifact list of a plugin",
        "parent": false,
        "code": "    private Field findPluginField( Class clazz, String key )\n        throws NoSuchFieldException\n    {\n        try\n        {\n            return clazz.getDeclaredField( key );\n        }\n        catch ( NoSuchFieldException e )\n        {\n            Class superclass = clazz.getSuperclass();\n            if ( superclass != Object.class )\n            {\n                return findPluginField( superclass, key );\n            }\n            else\n            {\n                throw e;\n            }\n        }\n    }",
        "start_line": 714,
        "changed": true,
        "commit": "3",
        "end_line": 733,
        "issue": "MNG-455",
        "description": "<p>When making plugins that will fork a java process and when this process requires all the dependencies of the plugin to be on the classpath this would be needed.</p>",
        "nl_input": "Access to the artifact list of a plugin\nWhen making plugins that will fork a java process and when this process requires all the dependencies of the plugin to be on the classpath this would be needed.",
        "method_name": "findPluginField"
    },
    {
        "path": "DefaultPluginManager.java",
        "summary": "Access to the artifact list of a plugin",
        "parent": false,
        "code": "    public static String createPluginParameterRequiredMessage( MojoDescriptor mojo, Parameter parameter,\n                                                              String expression )\n    {\n        StringBuffer message = new StringBuffer();\n\n        message.append( \"The '\" + parameter.getName() );\n        message.append( \"' parameter is required for the execution of the \" );\n        message.append( mojo.getFullGoalName() );\n        message.append( \" mojo and cannot be null.\" );\n        if ( expression != null )\n        {\n            message.append( \" The retrieval expression was: \" ).append( expression );\n        }\n\n        return message.toString();\n    }",
        "start_line": 735,
        "changed": true,
        "commit": "3",
        "end_line": 750,
        "issue": "MNG-455",
        "description": "<p>When making plugins that will fork a java process and when this process requires all the dependencies of the plugin to be on the classpath this would be needed.</p>",
        "nl_input": "Access to the artifact list of a plugin\nWhen making plugins that will fork a java process and when this process requires all the dependencies of the plugin to be on the classpath this would be needed.",
        "method_name": "createPluginParameterRequiredMessage"
    },
    {
        "path": "DefaultPluginManager.java",
        "summary": "Access to the artifact list of a plugin",
        "parent": false,
        "code": "    public void contextualize( Context context )\n        throws ContextException\n    {\n        container = (PlexusContainer) context.get( PlexusConstants.PLEXUS_KEY );\n\n        LoggerManager manager = null;\n\n        try\n        {\n            manager = (LoggerManager) container.lookup( LoggerManager.ROLE );\n\n            mojoLogger = new DefaultLog( manager.getLoggerForComponent( Mojo.ROLE ) );\n        }\n        catch ( ComponentLookupException e )\n        {\n            throw new ContextException( \"Error locating a logger manager\", e );\n        }\n        finally\n        {\n            if ( manager != null )\n            {\n                try\n                {\n                    container.release( manager );\n                }\n                catch ( ComponentLifecycleException e )\n                {\n                    getLogger().error( \"Error releasing the logger manager - ignoring\", e );\n                }\n            }\n        }\n    }",
        "start_line": 756,
        "changed": true,
        "commit": "3",
        "end_line": 787,
        "issue": "MNG-455",
        "description": "<p>When making plugins that will fork a java process and when this process requires all the dependencies of the plugin to be on the classpath this would be needed.</p>",
        "nl_input": "Access to the artifact list of a plugin\nWhen making plugins that will fork a java process and when this process requires all the dependencies of the plugin to be on the classpath this would be needed.",
        "method_name": "contextualize"
    },
    {
        "path": "DefaultPluginManager.java",
        "summary": "Access to the artifact list of a plugin",
        "parent": false,
        "code": "    public void initialize()\n    {\n        // TODO: configure this from bootstrap or scan lib\n        artifactFilter = new ExclusionSetFilter( new String[] {\n            \"classworlds\",\n            \"maven-artifact\",\n            \"maven-core\",\n            \"maven-model\",\n            \"maven-monitor\",\n            \"maven-plugin-api\",\n            \"maven-plugin-descriptor\",\n            \"maven-project\",\n            \"maven-settings\",\n            \"plexus-container-default\",\n            \"plexus-utils\",\n            \"wagon-provider-api\",\n            \"wagon-ssh\",\n            \"wagon-http-lightweight\",\n            \"wagon-file\" } );\n    }",
        "start_line": 789,
        "changed": true,
        "commit": "3",
        "end_line": 808,
        "issue": "MNG-455",
        "description": "<p>When making plugins that will fork a java process and when this process requires all the dependencies of the plugin to be on the classpath this would be needed.</p>",
        "nl_input": "Access to the artifact list of a plugin\nWhen making plugins that will fork a java process and when this process requires all the dependencies of the plugin to be on the classpath this would be needed.",
        "method_name": "initialize"
    },
    {
        "path": "DefaultPluginManager.java",
        "summary": "Access to the artifact list of a plugin",
        "parent": false,
        "code": "    private void resolveTransitiveDependencies( MavenSession context, ArtifactResolver artifactResolver,\n                                               MavenProjectBuilder mavenProjectBuilder, String scope )\n        throws ArtifactResolutionException\n    {\n        MavenProject project = context.getProject();\n\n        MavenMetadataSource sourceReader = new MavenMetadataSource( artifactResolver, mavenProjectBuilder );\n\n        ArtifactFilter filter = new ScopeArtifactFilter( scope );\n\n        boolean systemOnline = !context.getSettings().isOffline();\n\n        ArtifactResolutionResult result = artifactResolver.resolveTransitively( project.getArtifacts(), context\n            .getRemoteRepositories(), context.getLocalRepository(), sourceReader, filter );\n\n        project.addArtifacts( result.getArtifacts().values(), artifactFactory );\n    }",
        "start_line": 814,
        "changed": true,
        "commit": "3",
        "end_line": 830,
        "issue": "MNG-455",
        "description": "<p>When making plugins that will fork a java process and when this process requires all the dependencies of the plugin to be on the classpath this would be needed.</p>",
        "nl_input": "Access to the artifact list of a plugin\nWhen making plugins that will fork a java process and when this process requires all the dependencies of the plugin to be on the classpath this would be needed.",
        "method_name": "resolveTransitiveDependencies"
    },
    {
        "path": "DefaultPluginManager.java",
        "summary": "Access to the artifact list of a plugin",
        "parent": true,
        "code": "    private void downloadDependencies( MavenSession context, ArtifactResolver artifactResolver )\n        throws ArtifactResolutionException\n    {\n        for ( Iterator it = context.getProject().getArtifacts().iterator(); it.hasNext(); )\n        {\n            Artifact artifact = (Artifact) it.next();\n\n            // TODO: should I get the modified artifacts back into the project?\n            artifactResolver.resolve( artifact, context.getRemoteRepositories(), context.getLocalRepository() );\n        }\n\n        Set pluginArtifacts = new HashSet();\n        for ( Iterator it = context.getProject().getPluginArtifacts().iterator(); it.hasNext(); )\n        {\n            Artifact artifact = (Artifact) it.next();\n\n            artifactResolver.resolve( artifact, context.getRemoteRepositories(), context.getLocalRepository() );\n\n            pluginArtifacts.add( artifact );\n        }\n        context.getProject().setPluginArtifacts( pluginArtifacts );\n\n        artifactResolver.resolve( context.getProject().getParentArtifact(), context.getRemoteRepositories(), context\n            .getLocalRepository() );\n    }",
        "start_line": 836,
        "changed": false,
        "commit": "1",
        "end_line": 860,
        "issue": "MNG-455",
        "description": "<p>When making plugins that will fork a java process and when this process requires all the dependencies of the plugin to be on the classpath this would be needed.</p>",
        "nl_input": "Access to the artifact list of a plugin\nWhen making plugins that will fork a java process and when this process requires all the dependencies of the plugin to be on the classpath this would be needed.",
        "method_name": "downloadDependencies"
    },
    {
        "path": "DefaultPluginManager.java",
        "summary": "Access to the artifact list of a plugin",
        "parent": true,
        "code": "    private boolean isPluginInstalledForPrefix( String prefix )\n    {\n        return pluginDescriptorsByPrefix.containsKey( prefix );\n    }",
        "start_line": 862,
        "changed": false,
        "commit": "4",
        "end_line": 865,
        "issue": "MNG-455",
        "description": "<p>When making plugins that will fork a java process and when this process requires all the dependencies of the plugin to be on the classpath this would be needed.</p>",
        "nl_input": "Access to the artifact list of a plugin\nWhen making plugins that will fork a java process and when this process requires all the dependencies of the plugin to be on the classpath this would be needed.",
        "method_name": "isPluginInstalledForPrefix"
    }
]